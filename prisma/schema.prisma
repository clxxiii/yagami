// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Map {
  beatmap_id           String      @id
  fetch_time           DateTime    @default(now())
  approved             String?
  approved_date        DateTime?
  artist               String?
  artist_unicode       String?
  audio_unavailable    String?
  beatmapset_id        String?
  bpm                  String?
  count_normal         String?
  count_slider         String?
  count_spinner        String?
  creator              String?
  creator_id           String?
  diff_aim             String?
  diff_speed           String?
  diff_approach        String?
  diff_drain           String?
  diff_overall         String?
  diff_size            String?
  difficultyrating     String?
  download_unavailable String?
  favourite_count      String?
  file_md5             String?
  genre_id             String?
  hit_length           String?
  language_id          String?
  last_update          DateTime?
  max_combo            String?
  mode                 String?
  packs                String?
  passcount            String?
  playcount            String?
  rating               String?
  source               String?
  storyboard           String?
  submit_date          DateTime?
  tags                 String?
  title                String?
  title_unicode        String?
  total_length         String?
  version              String?
  video                String?
  in_pools             MapInPool[]
}

model MapInPool {
  identifier String // NM1, NM2 etc.
  mods       String
  Map        Map          @relation(fields: [mapId], references: [beatmap_id])
  mapId      String
  Mappool    Mappool      @relation(fields: [mappoolId], references: [id])
  mappoolId  Int
  InMatches  MapInMatch[]

  @@id([identifier, mappoolId])
}

model Mappool {
  id     Int         @id @default(autoincrement())
  maps   MapInPool[]
  global Boolean     @default(false)
  Round  Round?
}

model Round {
  id             Int        @id @default(autoincrement())
  acronym        String
  name           String
  bans           Int
  best_of        Int
  delete_warning String?
  show_mappool   Boolean
  Match          Match[]
  tournament     Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId   Int
  mappool        Mappool?   @relation(fields: [mappoolId], references: [id])
  mappoolId      Int?       @unique
}

model Tournament {
  id                  Int      @id @default(autoincrement())
  acronym             String
  name                String
  color               String
  force_nf            Boolean
  icon_url            String
  score_mode          Int
  team_mode           Int
  team_size           Int
  XvX_mode            Int
  allow_registrations Boolean
  rounds              Round[]
  Guild               Guild?   @relation(fields: [Guild_id], references: [guild_id])
  Guild_id            String?
  delete_warning      Boolean?
  double_pick         Int      @default(1) // 0: No double picking; 1: Only double picking NM; 2 Double Picking allowed
  double_ban          Int      @default(1) // 0: No double picking; 1: Only double picking NM; 2 Double Picking allowed
  Team                Team[]
}

model User {
  discord_id               String          @id
  discord_avatar           String
  discord_avatarURL        String
  discord_bot              Boolean
  discord_createdTimestamp Int
  discord_defaultAvatarURL String
  discord_discriminator    String
  discord_displayAvatarURL String
  discord_flags            Int
  discord_system           Boolean
  discord_tag              String
  discord_username         String
  osu_id                   Int
  osu_username             String
  osu_country_code         String
  osu_country_name         String
  osu_cover_url            String
  osu_ranked_score         Int
  osu_play_count           Int
  osu_total_score          Int
  osu_pp_rank              Int
  osu_level                Int
  osu_level_progress       Int
  osu_hit_accuracy         Float
  osu_pp                   Float
  token_access_token       String
  token_expires_in         Int
  token_refresh_token      String
  token_type               String
  in_teams                 UserInTeam[]
  ahrOwnerOf               AutoHostRotate?
}

model Guild {
  guild_id              String       @id
  change_nickname       Boolean
  linked_role           String?
  player_role           String?
  match_results_channel String?
  tournaments           Tournament[]
  active_tournament     Int?
}

model Team {
  id           Int           @id @default(autoincrement())
  name         String
  icon_url     String
  color        String
  members      UserInTeam[]
  tournament   Tournament    @relation(fields: [tournamentId], references: [id])
  tournamentId Int
  TeamInMatch  TeamInMatch[]
}

model UserInTeam {
  discordId      String
  user           User     @relation(fields: [discordId], references: [discord_id])
  Team           Team     @relation(fields: [teamId], references: [id])
  teamId         Int
  delete_warning Boolean?

  @@id([discordId, teamId])
}

model Match {
  id          Int
  teams       TeamInMatch[]
  message_id  String?
  channel_id  String?
  mp_link     String?
  waiting_on  Int? // Index of team in teams array
  Round       Round         @relation(fields: [roundId], references: [id])
  roundId     Int
  MapsInMatch MapInMatch[]
  state       Int

  @@id([id, roundId])
}

model TeamInMatch {
  matchId    Int
  teamId     Int
  roundId    Int
  match      Match        @relation(fields: [matchId, roundId], references: [id, roundId], onDelete: Cascade)
  Team       Team         @relation(fields: [teamId], references: [id], onDelete: Cascade)
  score      Int
  roll       Int?
  pick_order Int?
  ban_order  Int?
  warmedUp   Boolean      @default(false)
  Bans       MapInMatch[] @relation("banned")
  Wins       MapInMatch[] @relation("won")
  Picks      MapInMatch[] @relation("picked")
  winner     Boolean?

  @@id([teamId, matchId])
}

model MapInMatch {
  Map           MapInPool @relation(fields: [mapIdentifier, poolId], references: [identifier, mappoolId], onDelete: Cascade)
  Match         Match     @relation(fields: [matchId, roundId], references: [id, roundId], onDelete: Cascade)
  matchId       Int
  roundId       Int
  mapIdentifier String
  poolId        Int

  BannedByTeam    TeamInMatch? @relation(fields: [bannedByMatchId, bannedByTeamId], references: [matchId, teamId], name: "banned")
  bannedByTeamId  Int?
  bannedByMatchId Int?
  PickedByTeam    TeamInMatch? @relation(fields: [pickedByMatchId, pickedByTeamId], references: [matchId, teamId], name: "picked")
  pickedByTeamId  Int?
  pickedByMatchId Int?
  pickNumber      Int?
  pickTeamNumber  Int?
  won_by          TeamInMatch? @relation(fields: [wonByMatchId, wonByTeamId], references: [matchId, teamId], name: "won")
  wonByTeamId     Int?
  wonByMatchId    Int?
  @@id([mapIdentifier, matchId])
}

model AutoHostRotate {
  Owner       User                   @relation(fields: [discordId], references: [discord_id])
  discordId   String                 @id
  min_stars   Int?
  max_stars   Int?
  min_length  Int?
  max_length  Int?
  min_rank    Int?
  max_rank    Int?
  playerOrder AutoHostRotatePlayer[]
}

model AutoHostRotatePlayer {
  id       String         @id
  username String
  rank     Int
  lobbyId  String
  inLobby  AutoHostRotate @relation(fields: [lobbyId], references: [discordId])
  host     Boolean        @default(false)
}
